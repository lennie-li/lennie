@(framework)[seajs, requirejs]


# 模块框架


## 模块化的演变
> 代码维护的开闭原则：对添加开放，对修改封闭。
> 模块化的演变过程

1. 普通的方式，使用函数将代码封装。命名易产生冲突。
`function add(){}`
`function set(){}`

2. 使用对象将一类方法函数进行封装，需要调用方法时，调用对象内的方法即可。这种方式成为**命名空间**，降低命名冲突的概率。

	var o = {};
	o.set = function (a, b){...};
	o.add = function (a, b){...};
	
	var sum = o.add(1,2);


3. 	公有私有隔离，即使用**闭包**的方式来实现。进一步降低了命名冲突的概率，隔离了公有、私有成员，内部数据外界无法访问。

	var module = (function (){
		//私有变量外界无法访问
		var num1 = 1;
		var num2 = 2;
		var m = {
			add: function (a,b){...},
			set: function (a,b){...},	
		};
		//把需要暴露的公有数据 return 出去
		return m;
	})();


4. 模块的扩展，原则上不对原模块进行修改，只进行添加。使用该方法可以对模块进行扩展，而不影响原模块。对其他库的依赖也可以使用该方法，避免多个库之间命名的冲突( jQuery使用$ )。

		var module = (function (m){
			//私有变量外界无法访问
			var num1 = 1;
			var num2 = 2;
			function add(){...}
			function set(){...}
			m.add = add;
			m.set = set;
			//把需要暴露的公有数据 return 出去
			return m;
		})(module || {});
		var module = (function (m, $){
			function remove(){...}
			m.remove = remove;
			m.ajax = $.ajax;
			return m;
		})(module || {}, jQuery);


## 模块化框架

- 模块化规范
	- 浏览器端规范
		- AMD---requirejs 预加载 预执行（一开始全部加载了，速度快，浪费资源）
		- cmd---seajs 预加载 懒执行 （至下载下来了，什么时候用，什么时候加载，节省资源，速度较慢）
	
	- 服务器端规范
		- commonjs---nodejs


| 方案 | 优势 | 劣势 |  特点 |
| :---: | :---: | :---: | :---: |
|AMD | 速度快 | 会浪费资源 | 预先加载所有的依赖，直到使用的时候才执行 |
|CMD | 只有真正需要才加载依赖 | 性能较差 | 直到使用的时候才定义依赖 |





>作者：玉伯
链接：https://www.zhihu.com/question/20351507/answer/14859415
来源：知乎
著作权归作者所有，转载请联系作者获得授权。
区别：
1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：


		// CMD
		define(function(require, exports, module) {
		
		   var a = require('./a')
		
		       a.doSomething()
		
		    // 此处略去 100 行
		
		    var b = require('./b') 
		   // 依赖可以就近书写
		b.doSomething
		    // ... 
		
		})
	
	
		// AMD 默认推荐的是
		
		define(['./a', './b'], function(a, b) { 
		   // 依赖必须一开始就写好
		   
		a.doSomething()
		
		   // 此处略去 100 行
		
		    b.doSomething()
		
		}) 


>虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。

### seajs
- 加载=>定义=>导出=>导入
- 加载模块 


	//加载main模块
	//m为main.js中暴露的对象exports
	seajs.use('./main.js',function (m) {
		// module.js中通过expors 暴露出来的数据可以在这里调用
		m.add();
	})

	
- 定义、导出、导入模块

		//main.js
		
		//三个参数的名字是固定的不能修改
		//三个参数都可以省略，但是只能从后向前省略(类似于angular的注入)
		//定义模块
		define(function(require, exports, module) {
			//导入其他模块,并执行模块中的代码
			//导入module模块，并用m1来接收module中的exports
		    var m1 = require('./module.js');
		    //引入module2模块，module2中只有需要执行的代码，没有需要暴露的数据，不需要接收。
		    require('./module2.js');
		    function add() {
		        console.log('add');
		        //由于已经加载导入了module模块，并使m1接收了其返回值，所以可以使用m1调用其中的方法。
		        m1.sum();
		    }
		    //将add方法暴露出去
		    exports.add = add;
		});
		
		//module.js
		
		define(function (require,exports,module) {
			//引入其他模块
			function sum(){
				console.log('sum');
			}
			exports.sum = sum;
		});
		
		//module2.js
		
		define(function (require, exports, module) {
			//exports 与 module.exports 指向同一个对象
			console.log(exports === module.exports);
			console.log(exports);
			console.log(module.exports);
			console.log(module);
			//require用于依赖、引入其他模块
			//exports用于导出、暴露数据
			//module对象内的属性有：dependencies数组、deps对象包含依赖了哪些模块；exports包含暴露的数据；id、url代表模块的路径；status？
		});


- `exports` 与 `module.exports` 的关系
	- 一开始`exports` 与 `module.exports` 指向同一个对象，但最后**实际返回**的是`module.exports`所指向的对象。所以根据引用数据类型的特性，要为返回的数据添加成员：
		- 使用`exports`只能使用`.`语法来添加，若将一个新的对象赋值给`exports`，那么会改变`exports`的指向，而实际返回的数据为`module.exports`，刚才的赋值操作并没有改变`module.exports`所指向的对象，故而对返回的数据没有任何影响。
		- 使用`module.exports`使用`.`语法或将一个新对象重新赋值给`module.exports`都可以。


				<script>
					seajs.use('./m.js',function (m) {
						//最终拿到的m.js模块返回的数据，实际是module.exports所指向的对象
						console.log(m);//{a:1,b:2,c:4}
					})
				</script>



				define(function (require,exports,module) {
					console.log(exports);//{}
					//改变module.exports所指向的对象，但对exports指向的对象没有影响
					module.exports = {
						a:1,
						b:2
					};
					console.log(exports);//{}
					//改变exports所指向的对象
					exports = {c:3};
					console.log(exports);//{c:3}
					//为module.exports添加新成员
					module.exports.c = 4;
				});

- 异步的形式加载模块
	- seajs中 `require` 模块时，内部其实是通过动态创建 script 标签并指定 `src` 属性，来导入 js 文件。但内部有机制来判断前部的 js 文件是否以前完全加载，若完全加载才会继续执行后部的模块。若报错则不会继续执行。看起来，是以**同步方式**来执行的。
	- 若想以异步的方式来引入模块：`require.async('src', function(){...})`

- 依赖jQuery库及其他框架
	- 由于seajs是基于CMD规范的，而jquery默认是支持AMD规范的，需要对jquery源码进行一点修改


			//如果define是一个函数的话，且遵循amd规范	//那么jquery就可以自动模块化
			if ( typeof define === "function" && define.amd ) { 
				define( "jquery", [], function () { 
					return jQuery; 
				} 
			);}

		修改为
	
			if ( typeof define === "function" && (define.amd || define，cmd)) { 
				define( "jquery", [], function () { 
					return jQuery; 
				} 
			);}

		或者修改为

			if ( typeof define === "function") { 
				define( "jquery", [], function () { 
					return jQuery; 
				} 
			);}


		修改过后jquery就可以自动模块化了


		- 除了通常的引入模块的方法，还可以通过一下方式引入模块，路径过长使用变量储存，简写


				//html 的js 文件
				seajs.config({
					//将jQuery的路径保存在一个变量中
					//注意！该路径是相对于 需要依赖jquery的模块的文件 的路径，而不是当前文件
					//如此处在main.js主模块中依赖了jquery，那么路径就应该是 jquery.js相对与main.js 的路径
					//项目中建议使用绝对路径
					alias: {
						jquery: '../node_modules/jquery/dist/jquery.js'
					}
				});
				//依赖主模块
				seajs.use('./js/main.js', function(main) {
				
				});
		
				
		
				//main.js
				define(function (require, exports, module) {
					var $ = require('jquery');
				});




### requirejs

- 使用方法与seajs基本相同

1. 引入
2. 声明入口文件
`<script scr="./xxx.js" data-main="./main"></script>`引包的同时，定义data-main自定义属性，声明入口文件（此处表示当前文件的main.js为入口文件）
3. define定义模块
4. 使用模块，依赖其他模块

	
		//此处的a,b就是a.js,b.js中return的数据。可以return任意数据
		define(['a,js','b,js'],function(a,b){
			...
			return xxx
			
		})




