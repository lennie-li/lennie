@(JavaScript)[RegExp, js]

# 正则表达式 

> 正则表达式对象

- js 正则表达式对象 就是 由 正则表达式创建的对象, 该对象可以进行 匹配, 提取 和 替换.
- 创建正则表达式对象
	- 构造函数
		

	var regex = new RegExp(正则表达式字符串 [, 匹配模式] );
	var regex = new RegExp("abc");

		
	- 字面量

				var regex = /abc/;
				
- 构造函数与字面量的区别
	- 使用构造函数和字面量创建正则表达式对象时，正则表达式的转义字符的使用不同。
	- 由于构造函数内的正则表达式本身就是字符串，所以转义字符用法与字面量内的转义字符用法相反，一般使用字面量形式创建正则表达式。
  
  
> 元字符

- 基本元字符
	-  `.`  表示任意一个非换行字符
	-  `( )` 表示分组和提高优先级
	-  `[ ]` 表示一个字符
		-  `[abc]`   一个a或b或c的字符
	- | 或   
		- `RegExp1 | RexExp2`
	- \ 转义字符 
		- 将正则表达式内的特殊含义字符转换为普通字符 
-  限定元字符
	-  `*` 紧跟在该字符前的一个字符或一组字符可以出现0次到多次
	-  `+` 紧跟在该字符前的一个字符或一组字符可以出现1次到多次
	-  `?`  紧跟在该字符前的一个字符或一组字符可以出现0次到1次
	-  `{num}`  紧跟在该字符前的一个字符或一组字符可以出现指定的num次 
		-  `a{2}` ===>  aa   aab  a出现两次
	-  `{num , }`  紧跟在该字符前的一个字符或一组字符可以出现num次到多次
		-  `a{2,}`  ===>  aa aaa aaaa  a出现至少两次
	-  `{num1，num2}` 紧跟在该字符前的一个字符或一组字符可以出现num1次到num2次
		-  `a{2,4}` ===> aa aaa aaaa  a出现2次 3次 或4次
- 首尾正则表达式
	-  `^` 以xxx开头
	-  `$` 以xxx结尾
- 简写元字符
	- `\s`  空白字符 包括空格、tab、回车、换行
	- `\S` 非空白字符
	- `\w`  表示字符，包括字母、数字、下划线
	- `\W` 非字符
	- `\d` 数字
	- `\D` 非数字
- 否定元字符
	- `^` 非
		- `[^字符]` 不是这些字符的其他字符
		- `[^abc]` 一个不是a或b或c的字符

- 匹配但是不捕获的元字符
	- `(?:正则表达式内容)`
	- 获取、操作正则表达式获得的字符串时，减少捕获的内容，减少性能消耗。

- 阻止贪婪模式的元字符
	- 取消贪婪模式. 在次数限定符后面加上 `?`
	- 凡是在正则表达式中, 涉及到次数限定的, 一般默认都是尽可能的多匹配.
	- 注意: 贪婪模式性能会略高于非贪婪模式, 所以开发的时候. 一般不考虑贪婪的问题
		只有代码匹配结果出现问题了, 一般一次多匹配了, 才会取消贪婪
	- 多个贪婪在一起的时候的强度
	`\d+\d+\d+`
	1234567  ==> 12345   6   7
	- 如果取消贪婪模式
	`\d+?\d+\d+ `
	1234567 ==> 1  23456  7
 
 
>  匹配模式

-  g  全局模式global
- `var regex = /abc123def456ghi789jkl/g ;`
- `var regex1 = new RegExp ("abc123def456ghi789jkl" , "g");`
 
  
> 方法

- 检查 test 
	- 正则表达式对象.test(字符串); //返回true 或 false

			var regex = /abc/;
			var str = "abcdefg";
			var result =  regex.test(str);
			console.log(result); //true
- 提取 exec 
	- 使用正则表达式进行匹配，使用exec可以将匹配到的数据提取出来
	- 正则表达式对象.exec(字符串);// 返回一个数组，数组内保存匹配到的数据
	- 注意，在非全局模式下（/abc/   /abc/g）,默认返回一个数据后就终止匹配
- 循环提取
	- 在一个字符串中将所有复合的要求的字符串提取出来
	- 正则表达式需要使用全局模式

			var r = new RegExp( '正则', 'g' );
			var r = /正则/g;

	- 调用 exec 首先获得第一个匹配项再调用一次该方法, 就可以获得 第二个匹配项一直调用下去, 就可以得到所有的匹配项直到最后全部匹配完, 如果还用该方法, 则返回 null
	- 案例：在 'abc123def456ghij789klum' 提取数字

			var r = /\d+/g;
			r.exec( str )			=> 123
			r.exec( str )			=> 456
			r.exec( str )			=> 789
			r.exec( str )			=> null

			while ( res = r.exec( str ) ) {
				// 操作 res, 处理捕获的结果
			}
- 提取结果解析
	- 将匹配到的结果进行解析，假如有一个字符串: itcast@itcast.cn，匹配提取邮箱, 同时将邮箱地址部分的名字和主机名都提取出来
	- 案例:
	
			var str = '我有一个邮箱, 是 itcast@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com'
			要求将里面的邮箱全部提取出来, 然后将名字还有主机名也取出来
		
		
			// 循环提取的正则表达式
			var r = /[a-zA-Z\d]+@[a-zA-Z\d]+(\.[a-zA-Z\d]+)+/g;
		
			// 如果需要将匹配到的结果再次分解, 可以使用分组的形式, 在正则中分组即可
		
			var r = /([a-zA-Z\d]+)@([a-zA-Z\d]+(\.[a-zA-Z\d]+)+)/g;
		
			// 注意, 正则表达式中, 分组是有编号的. 从左往右数 '('. 从 1 开始依次编号
			// 匹配提取的结果中, 对应的编号就可以获得分解的数据


- 字符串的替换
	- 字符串.replace( 查找字符串 ， 替换字符串 ) -->返回替换后的字符串//只替换找到的第一个字符串
		- "aaa".replace("a","b") ;==>"baa"
	- 正则替换
		- 字符串.replace( 正则表达式， 字符串 ) -->返回替换后的字符串
			- 简单替换  
				` "aaaaa------bbbbbb------cccccc".replace( /-+/g , "-" ); //"aaaaa-bbbbbb-cccccc"  `
			- 分组替换
				- 可以在替换字符串中，使用$数字，来引用替换的数据
				` "abc123".replace( /(\d+)/ , "d$1" ); //"abcd123" `

						'1991-1-1'
						中国: 1991年1月1日
						欧洲: 1/1/1991
						... : 1991 1 1	
						'1991-1-19'.replace( /(\d+)-(\d+)-(\d+)/, '$1年$2月$3日' )
	- 函数参数用法
		- 语法: ` 字符串.replace( 正则表达式 ， fn ) `
		- 案例 ：
			
				"我的邮箱是：lennie@itcast.com.cn，你的邮箱是：abc@163.com"
				.replace( / ( \ w ) + @ ( \ w + ( \ . \ w + ) + )/g , function ( string , g1 , g2 , g3 ) { //string 是通过正则表达式匹配的字符串，g1,g2,g3是 每个括号分组内的字符串
				//需求 将邮箱变为 l********@主机名
					var first = g1.charAt( 0 );
					var start = [];
					for ( var i = 0 ; i<g1.length-1 ;  i++ ){
						start.push("*");
					}
					return first + start.join("") + "@" + g2 ;
				} )

- 写正则正则表达式的三要素
	- 找什么
	- 找几个
	- 在哪找